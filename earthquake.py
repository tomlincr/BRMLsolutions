# -*- coding: utf-8 -*-
"""
Created on Mon Nov  9 12:54:09 2020

@author: chris
"""

import numpy as np
import matplotlib.pyplot as plt
import earthquakeExerciseSetup as setup


def value(x_true,y_true,x_sensor,y_sensor):
    return 1/(0.1+ (x_true-x_sensor)**2 + (y_true-y_sensor)**2)

# run coordinate system setup
setup.earthquake_exercise_setup()

# define the coordinate system:
S=5000 # number of points on the spiral
x=np.zeros(S); y=np.zeros(S)
for s in range(S):
    theta=50*2*np.pi*s/S
    r=s/S
    x[s]=r*np.cos(theta); y[s]=r*np.sin(theta)
    plt.plot(x,y,".")
    
# define the locations of the detection stations on the surface
# Also define what value on each sensor would be generated by an explostion at internal location s
N=10 # number of stations
x_sensor=np.zeros(N); y_sensor=np.zeros(N)
v=np.zeros((S,N))
for sensor in range(N):
    theta_sensor=2*np.pi*sensor/N
    x_sensor[sensor]=np.cos(theta_sensor); y_sensor[sensor]=np.sin(theta_sensor)
for s in range(S):
    v[s,sensor]=value(x[s],y[s],x_sensor[sensor],y_sensor[sensor]) # explosion value

sd=1 # standard deviation of the Gaussian noise

# Make the explosion data:
true_s=np.random.permutation(S)[1] # true location of the explosion
theta=50*2*np.pi*true_s/S
r=true_s/S
x_true=r*np.cos(theta); y_true=r*np.sin(theta)

# Get the noisy sensor values that will be observed for this explosion:
val=np.zeros(N)
val_clean=np.zeros(N) # unknown clean values (just for interest)
for sensor in range(N):
    val_clean[sensor]=value(x_true,y_true,x_sensor[sensor],y_sensor[sensor])
    val[sensor]=val_clean[sensor]+sd*np.random.randn()

plt.figure()
plt.plot(range(0,N),val,label="noisy observed sensor measurements")
plt.plot(range(0,N),val_clean,label="clean (unknown) sensor measurements")
plt.legend()

# Perform inference p(location|observed sensor values) given these sensor values
logp=np.zeros(S)
for s in range(0,S):
    for sensor in range(0, N):
        logp[s] += -0.5*(val[sensor]-v[s,sensor])**2/(sd**2) # Gaussian distribution
# p=exp.(logp-maximum(logp)) # do exponentiation (and avoid over/underflow)
p=np.exp(logp)
p=p/sum(p) # normalise

# plot the posterior and most likely location of the explosion:
#maxp,maxind =max(p)
maxp = float(np.max(p))# coerce to float instead of npfloat64
maxind = np.where(p == np.max(p))[0][0] # extract integer of index


plt.figure()
for s in range(0,S):
    plt.plot(x[s],y[s],".",color=(1-(p[s]/maxp))*np.array([1,1,1]))
    
# for theta=0:0.01:2*np.pi
for theta in np.arange(0,2*np.pi,0.01):
    plt.plot(np.cos(theta),np.sin(theta),".",color=[0,0,0])
    
for sensor in range(0, N):
    plt.plot(x_sensor[sensor],y_sensor[sensor],"o",color=[1,0,0])
    
plt.plot(x_true,y_true,"rx",markersize=20,label="true")
plt.plot(x[maxind],y[maxind],"m+",markersize=20,label="estimated (most likely)")
#plt.plot(sum(p.*x),sum(p.*y),"go",markersize=10,label="estimated (average)")
plt.plot(sum(p*x),sum(p*y),"go",markersize=10,label="estimated (average)")
plt.legend()
